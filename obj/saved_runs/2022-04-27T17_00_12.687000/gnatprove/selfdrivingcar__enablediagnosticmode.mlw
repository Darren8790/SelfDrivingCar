module Selfdrivingcar__onoff
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type onoff
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = onoff,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type onoff__ref = { mutable onoff__content : onoff }
  
  function onoff__ref_onoff__content__projection (a: onoff__ref) : onoff =
    a.onoff__content
  
  meta "model_projection" function onoff__ref_onoff__content__projection
  
  meta "inline:no" function onoff__ref_onoff__content__projection
  
  val onoff__havoc (x: onoff__ref) : unit
    writes { x }
end

module Selfdrivingcar__onoff__rep
  use Selfdrivingcar__onoff as Selfdrivingcar__onoff
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__onoff.onoff,
    predicate in_range = Selfdrivingcar__onoff.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__gearbox
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type gearbox
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (2 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = gearbox,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type gearbox__ref = { mutable gearbox__content : gearbox }
  
  function gearbox__ref_gearbox__content__projection (a: gearbox__ref) : gearbox =
    a.gearbox__content
  
  meta "model_projection" function gearbox__ref_gearbox__content__projection
  
  meta "inline:no" function gearbox__ref_gearbox__content__projection
  
  val gearbox__havoc (x: gearbox__ref) : unit
    writes { x }
end

module Selfdrivingcar__gearbox__rep
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__gearbox.gearbox,
    predicate in_range = Selfdrivingcar__gearbox.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__chargelevel
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type chargelevel = <range 0 100>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (100 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = chargelevel,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type chargelevel__ref = { mutable chargelevel__content : chargelevel }
  
  function chargelevel__ref_chargelevel__content__projection (a: chargelevel__ref) : chargelevel =
    a.chargelevel__content
  
  meta "model_projection" function chargelevel__ref_chargelevel__content__projection
  
  meta "inline:no" function chargelevel__ref_chargelevel__content__projection
  
  val chargelevel__havoc (x: chargelevel__ref) : unit
    writes { x }
end

module Selfdrivingcar__chargelevel__rep
  use Selfdrivingcar__chargelevel as Selfdrivingcar__chargelevel
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Selfdrivingcar__chargelevel.chargelevel) : int =
    Selfdrivingcar__chargelevel.chargelevel'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__chargelevel.chargelevel,
    predicate in_range = Selfdrivingcar__chargelevel.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__carspeed
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type carspeed = <range 0 100>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (100 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = carspeed,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type carspeed__ref = { mutable carspeed__content : carspeed }
  
  function carspeed__ref_carspeed__content__projection (a: carspeed__ref) : carspeed =
    a.carspeed__content
  
  meta "model_projection" function carspeed__ref_carspeed__content__projection
  
  meta "inline:no" function carspeed__ref_carspeed__content__projection
  
  val carspeed__havoc (x: carspeed__ref) : unit
    writes { x }
end

module Selfdrivingcar__carspeed__rep
  use Selfdrivingcar__carspeed as Selfdrivingcar__carspeed
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Selfdrivingcar__carspeed.carspeed) : int =
    Selfdrivingcar__carspeed.carspeed'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__carspeed.carspeed,
    predicate in_range = Selfdrivingcar__carspeed.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__object
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type object
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = object,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type object__ref = { mutable object__content : object }
  
  function object__ref_object__content__projection (a: object__ref) : object =
    a.object__content
  
  meta "model_projection" function object__ref_object__content__projection
  
  meta "inline:no" function object__ref_object__content__projection
  
  val object__havoc (x: object__ref) : unit
    writes { x }
end

module Selfdrivingcar__object__rep
  use Selfdrivingcar__object as Selfdrivingcar__object
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__object.object,
    predicate in_range = Selfdrivingcar__object.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__diagnosticmode
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type diagnosticmode
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = diagnosticmode,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type diagnosticmode__ref = {
                            mutable diagnosticmode__content : diagnosticmode
                            }
  
  function diagnosticmode__ref_diagnosticmode__content__projection (a: diagnosticmode__ref) : diagnosticmode =
    a.diagnosticmode__content
  
  meta "model_projection" function diagnosticmode__ref_diagnosticmode__content__projection
  
  meta "inline:no" function diagnosticmode__ref_diagnosticmode__content__projection
  
  val diagnosticmode__havoc (x: diagnosticmode__ref) : unit
    writes { x }
end

module Selfdrivingcar__diagnosticmode__rep
  use Selfdrivingcar__diagnosticmode as Selfdrivingcar__diagnosticmode
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__diagnosticmode.diagnosticmode,
    predicate in_range = Selfdrivingcar__diagnosticmode.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__chargestate
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type chargestate
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (2 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = chargestate,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type chargestate__ref = { mutable chargestate__content : chargestate }
  
  function chargestate__ref_chargestate__content__projection (a: chargestate__ref) : chargestate =
    a.chargestate__content
  
  meta "model_projection" function chargestate__ref_chargestate__content__projection
  
  meta "inline:no" function chargestate__ref_chargestate__content__projection
  
  val chargestate__havoc (x: chargestate__ref) : unit
    writes { x }
end

module Selfdrivingcar__chargestate__rep
  use Selfdrivingcar__chargestate as Selfdrivingcar__chargestate
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__chargestate.chargestate,
    predicate in_range = Selfdrivingcar__chargestate.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__car__rep
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__onoff as Selfdrivingcar__onoff
  use Selfdrivingcar__onoff__rep as Selfdrivingcar__onoff__rep
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  use Selfdrivingcar__gearbox__rep as Selfdrivingcar__gearbox__rep
  use Selfdrivingcar__chargelevel as Selfdrivingcar__chargelevel
  use Selfdrivingcar__chargelevel__rep as Selfdrivingcar__chargelevel__rep
  use Selfdrivingcar__carspeed as Selfdrivingcar__carspeed
  use Selfdrivingcar__carspeed__rep as Selfdrivingcar__carspeed__rep
  use Selfdrivingcar__object as Selfdrivingcar__object
  use Selfdrivingcar__object__rep as Selfdrivingcar__object__rep
  use Selfdrivingcar__diagnosticmode as Selfdrivingcar__diagnosticmode
  use Selfdrivingcar__diagnosticmode__rep as Selfdrivingcar__diagnosticmode__rep
  use Selfdrivingcar__chargestate as Selfdrivingcar__chargestate
  use Selfdrivingcar__chargestate__rep as Selfdrivingcar__chargestate__rep
  
  type __split_fields = {
                       rec__selfdrivingcar__car__gear :
                         Selfdrivingcar__gearbox.gearbox;
                       rec__selfdrivingcar__car__switch :
                         Selfdrivingcar__onoff.onoff;
                       rec__selfdrivingcar__car__battery :
                         Selfdrivingcar__chargelevel.chargelevel;
                       rec__selfdrivingcar__car__speed :
                         Selfdrivingcar__carspeed.carspeed;
                       rec__selfdrivingcar__car__sensor :
                         Selfdrivingcar__object.object;
                       rec__selfdrivingcar__car__diagnostic :
                         Selfdrivingcar__diagnosticmode.diagnosticmode;
                       rec__selfdrivingcar__car__charge :
                         Selfdrivingcar__chargestate.chargestate
                       }
  
  function __split_fields_rec__selfdrivingcar__car__gear__projection (a: __split_fields) : 
    Selfdrivingcar__gearbox.gearbox =
    a.rec__selfdrivingcar__car__gear
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__gear__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__gear__projection
  
  function __split_fields_rec__selfdrivingcar__car__switch__projection (a: __split_fields) : 
    Selfdrivingcar__onoff.onoff =
    a.rec__selfdrivingcar__car__switch
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__switch__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__switch__projection
  
  function __split_fields_rec__selfdrivingcar__car__battery__projection (a: __split_fields) : 
    Selfdrivingcar__chargelevel.chargelevel =
    a.rec__selfdrivingcar__car__battery
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__battery__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__battery__projection
  
  function __split_fields_rec__selfdrivingcar__car__speed__projection (a: __split_fields) : 
    Selfdrivingcar__carspeed.carspeed =
    a.rec__selfdrivingcar__car__speed
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__speed__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__speed__projection
  
  function __split_fields_rec__selfdrivingcar__car__sensor__projection (a: __split_fields) : 
    Selfdrivingcar__object.object =
    a.rec__selfdrivingcar__car__sensor
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__sensor__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__sensor__projection
  
  function __split_fields_rec__selfdrivingcar__car__diagnostic__projection (a: __split_fields) : 
    Selfdrivingcar__diagnosticmode.diagnosticmode =
    a.rec__selfdrivingcar__car__diagnostic
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__diagnostic__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__diagnostic__projection
  
  function __split_fields_rec__selfdrivingcar__car__charge__projection (a: __split_fields) : 
    Selfdrivingcar__chargestate.chargestate =
    a.rec__selfdrivingcar__car__charge
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__charge__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__charge__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__projection
  
  meta "inline:no" function __rep___split_fields__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate selfdrivingcar__car__gear__pred (a: __rep) = true
  
  val selfdrivingcar__car__gear__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__gear__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__gear_ (a: __rep) : Selfdrivingcar__gearbox.gearbox
    requires { selfdrivingcar__car__gear__pred a }
    ensures { (result = ((__split_fields a).rec__selfdrivingcar__car__gear)) }
  
  predicate selfdrivingcar__car__switch__pred (a: __rep) = true
  
  val selfdrivingcar__car__switch__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__switch__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__switch_ (a: __rep) : Selfdrivingcar__onoff.onoff
    requires { selfdrivingcar__car__switch__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__switch)) }
  
  predicate selfdrivingcar__car__battery__pred (a: __rep) = true
  
  val selfdrivingcar__car__battery__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__battery__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__battery_ (a: __rep) : Selfdrivingcar__chargelevel.chargelevel
    requires { selfdrivingcar__car__battery__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__battery)) }
  
  predicate selfdrivingcar__car__speed__pred (a: __rep) = true
  
  val selfdrivingcar__car__speed__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__speed__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__speed_ (a: __rep) : Selfdrivingcar__carspeed.carspeed
    requires { selfdrivingcar__car__speed__pred a }
    ensures { (result = ((__split_fields a).rec__selfdrivingcar__car__speed)) }
  
  predicate selfdrivingcar__car__sensor__pred (a: __rep) = true
  
  val selfdrivingcar__car__sensor__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__sensor__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__sensor_ (a: __rep) : Selfdrivingcar__object.object
    requires { selfdrivingcar__car__sensor__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__sensor)) }
  
  predicate selfdrivingcar__car__diagnostic__pred (a: __rep) = true
  
  val selfdrivingcar__car__diagnostic__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__diagnostic__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__diagnostic_ (a: __rep) : Selfdrivingcar__diagnosticmode.diagnosticmode
    requires { selfdrivingcar__car__diagnostic__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__diagnostic)) }
  
  predicate selfdrivingcar__car__charge__pred (a: __rep) = true
  
  val selfdrivingcar__car__charge__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__charge__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__charge_ (a: __rep) : Selfdrivingcar__chargestate.chargestate
    requires { selfdrivingcar__car__charge__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__charge)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if ((((Selfdrivingcar__gearbox__rep.to_rep
             ((__split_fields a).rec__selfdrivingcar__car__gear))
            = (Selfdrivingcar__gearbox__rep.to_rep
                 ((__split_fields b).rec__selfdrivingcar__car__gear))) /\
           ((Selfdrivingcar__onoff__rep.to_rep
               ((__split_fields a).rec__selfdrivingcar__car__switch))
              = (Selfdrivingcar__onoff__rep.to_rep
                   ((__split_fields b).rec__selfdrivingcar__car__switch)))) /\
          (((((Selfdrivingcar__chargelevel__rep.to_rep
                 ((__split_fields a).rec__selfdrivingcar__car__battery))
                = (Selfdrivingcar__chargelevel__rep.to_rep
                     ((__split_fields b).rec__selfdrivingcar__car__battery))) /\
               ((Selfdrivingcar__carspeed__rep.to_rep
                   ((__split_fields a).rec__selfdrivingcar__car__speed))
                  = (Selfdrivingcar__carspeed__rep.to_rep
                       ((__split_fields b).rec__selfdrivingcar__car__speed)))) /\
              ((Selfdrivingcar__object__rep.to_rep
                  ((__split_fields a).rec__selfdrivingcar__car__sensor))
                 = (Selfdrivingcar__object__rep.to_rep
                      ((__split_fields b).rec__selfdrivingcar__car__sensor)))) /\
             (((Selfdrivingcar__diagnosticmode__rep.to_rep
                  ((__split_fields a).rec__selfdrivingcar__car__diagnostic))
                 = (Selfdrivingcar__diagnosticmode__rep.to_rep
                      ((__split_fields b).rec__selfdrivingcar__car__diagnostic))) /\
                ((Selfdrivingcar__chargestate__rep.to_rep
                    ((__split_fields a).rec__selfdrivingcar__car__charge))
                   = (Selfdrivingcar__chargestate__rep.to_rep
                        ((__split_fields b).rec__selfdrivingcar__car__charge)))))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Selfdrivingcar__car
  use export Selfdrivingcar__car__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type car = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function selfdrivingcar__car__gear__first__bit : int
  
  val function selfdrivingcar__car__gear__last__bit : int
  
  val function selfdrivingcar__car__gear__position : int
  
  axiom selfdrivingcar__car__gear__first__bit_axiom:
    (selfdrivingcar__car__gear__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__gear__last__bit_axiom:
    (selfdrivingcar__car__gear__last__bit
       > selfdrivingcar__car__gear__first__bit)
  
  axiom selfdrivingcar__car__gear__position_axiom:
    (selfdrivingcar__car__gear__position >= (0 : int))
  
  val function selfdrivingcar__car__switch__first__bit : int
  
  val function selfdrivingcar__car__switch__last__bit : int
  
  val function selfdrivingcar__car__switch__position : int
  
  axiom selfdrivingcar__car__switch__first__bit_axiom:
    (selfdrivingcar__car__switch__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__switch__last__bit_axiom:
    (selfdrivingcar__car__switch__last__bit
       > selfdrivingcar__car__switch__first__bit)
  
  axiom selfdrivingcar__car__switch__position_axiom:
    (selfdrivingcar__car__switch__position >= (0 : int))
  
  val function selfdrivingcar__car__battery__first__bit : int
  
  val function selfdrivingcar__car__battery__last__bit : int
  
  val function selfdrivingcar__car__battery__position : int
  
  axiom selfdrivingcar__car__battery__first__bit_axiom:
    (selfdrivingcar__car__battery__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__battery__last__bit_axiom:
    (selfdrivingcar__car__battery__last__bit
       > selfdrivingcar__car__battery__first__bit)
  
  axiom selfdrivingcar__car__battery__position_axiom:
    (selfdrivingcar__car__battery__position >= (0 : int))
  
  val function selfdrivingcar__car__speed__first__bit : int
  
  val function selfdrivingcar__car__speed__last__bit : int
  
  val function selfdrivingcar__car__speed__position : int
  
  axiom selfdrivingcar__car__speed__first__bit_axiom:
    (selfdrivingcar__car__speed__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__speed__last__bit_axiom:
    (selfdrivingcar__car__speed__last__bit
       > selfdrivingcar__car__speed__first__bit)
  
  axiom selfdrivingcar__car__speed__position_axiom:
    (selfdrivingcar__car__speed__position >= (0 : int))
  
  val function selfdrivingcar__car__sensor__first__bit : int
  
  val function selfdrivingcar__car__sensor__last__bit : int
  
  val function selfdrivingcar__car__sensor__position : int
  
  axiom selfdrivingcar__car__sensor__first__bit_axiom:
    (selfdrivingcar__car__sensor__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__sensor__last__bit_axiom:
    (selfdrivingcar__car__sensor__last__bit
       > selfdrivingcar__car__sensor__first__bit)
  
  axiom selfdrivingcar__car__sensor__position_axiom:
    (selfdrivingcar__car__sensor__position >= (0 : int))
  
  val function selfdrivingcar__car__diagnostic__first__bit : int
  
  val function selfdrivingcar__car__diagnostic__last__bit : int
  
  val function selfdrivingcar__car__diagnostic__position : int
  
  axiom selfdrivingcar__car__diagnostic__first__bit_axiom:
    (selfdrivingcar__car__diagnostic__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__diagnostic__last__bit_axiom:
    (selfdrivingcar__car__diagnostic__last__bit
       > selfdrivingcar__car__diagnostic__first__bit)
  
  axiom selfdrivingcar__car__diagnostic__position_axiom:
    (selfdrivingcar__car__diagnostic__position >= (0 : int))
  
  val function selfdrivingcar__car__charge__first__bit : int
  
  val function selfdrivingcar__car__charge__last__bit : int
  
  val function selfdrivingcar__car__charge__position : int
  
  axiom selfdrivingcar__car__charge__first__bit_axiom:
    (selfdrivingcar__car__charge__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__charge__last__bit_axiom:
    (selfdrivingcar__car__charge__last__bit
       > selfdrivingcar__car__charge__first__bit)
  
  axiom selfdrivingcar__car__charge__position_axiom:
    (selfdrivingcar__car__charge__position >= (0 : int))
  
  val function user_eq (a: car) (b: car) : bool
  
  val function dummy : car
  
  type car__ref = { mutable car__content : car }
  
  function car__ref_car__content__projection (a: car__ref) : car =
    a.car__content
  
  meta "model_projection" function car__ref_car__content__projection
  
  meta "inline:no" function car__ref_car__content__projection
  
  val car__havoc (x: car__ref) : unit
    writes { x }
end

module Selfdrivingcar__thecar
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  val thecar__split_fields : Selfdrivingcar__car.__split_fields__ref
end

module Selfdrivingcar__car___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  predicate dynamic_invariant (temp___expr_222: Selfdrivingcar__car.car) (temp___is_init_218: bool) (temp___skip_constant_219: bool) (temp___do_toplevel_220: bool) (temp___do_typ_inv_221: bool) =
    true
  
  val dynamic_invariant (temp___expr_222: Selfdrivingcar__car.car) (temp___is_init_218: bool) (temp___skip_constant_219: bool) (temp___do_toplevel_220: bool) (temp___do_typ_inv_221: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_222 : Selfdrivingcar__car.car))
                      (temp___is_init_218 : bool))
                     (temp___skip_constant_219 : bool))
                    (temp___do_toplevel_220 : bool))
                   (temp___do_typ_inv_221 : bool)) }
  
  predicate default_initial_assumption (temp___expr_223: Selfdrivingcar__car.car) (temp___skip_top_level_224: bool) =
    true
  
  val default_initial_assumption (temp___expr_223: Selfdrivingcar__car.car) (temp___skip_top_level_224: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_223 : Selfdrivingcar__car.car))
                   (temp___skip_top_level_224 : bool)) }
end

module Selfdrivingcar__onoff___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__onoff as Selfdrivingcar__onoff
  
  predicate dynamic_invariant (temp___expr_166: int) (temp___is_init_162: bool) (temp___skip_constant_163: bool) (temp___do_toplevel_164: bool) (temp___do_typ_inv_165: bool) =
    if ((temp___is_init_162 = True) \/
          (Selfdrivingcar__onoff.first <= Selfdrivingcar__onoff.last)) then
      (((Selfdrivingcar__onoff.dynamic_property Selfdrivingcar__onoff.first)
          Selfdrivingcar__onoff.last)
         temp___expr_166)
    else true
  
  val dynamic_invariant (temp___expr_166: int) (temp___is_init_162: bool) (temp___skip_constant_163: bool) (temp___do_toplevel_164: bool) (temp___do_typ_inv_165: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_166 : int))
                      (temp___is_init_162 : bool))
                     (temp___skip_constant_163 : bool))
                    (temp___do_toplevel_164 : bool))
                   (temp___do_typ_inv_165 : bool)) }
  
  predicate default_initial_assumption (temp___expr_167: int) (temp___skip_top_level_168: bool) =
    true
  
  val default_initial_assumption (temp___expr_167: int) (temp___skip_top_level_168: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_167 : int))
                   (temp___skip_top_level_168 : bool)) }
end

module Selfdrivingcar__gearbox___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  
  predicate dynamic_invariant (temp___expr_173: int) (temp___is_init_169: bool) (temp___skip_constant_170: bool) (temp___do_toplevel_171: bool) (temp___do_typ_inv_172: bool) =
    if ((temp___is_init_169 = True) \/
          (Selfdrivingcar__gearbox.first <= Selfdrivingcar__gearbox.last)) then
      (((Selfdrivingcar__gearbox.dynamic_property
           Selfdrivingcar__gearbox.first)
          Selfdrivingcar__gearbox.last)
         temp___expr_173)
    else true
  
  val dynamic_invariant (temp___expr_173: int) (temp___is_init_169: bool) (temp___skip_constant_170: bool) (temp___do_toplevel_171: bool) (temp___do_typ_inv_172: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_173 : int))
                      (temp___is_init_169 : bool))
                     (temp___skip_constant_170 : bool))
                    (temp___do_toplevel_171 : bool))
                   (temp___do_typ_inv_172 : bool)) }
  
  predicate default_initial_assumption (temp___expr_174: int) (temp___skip_top_level_175: bool) =
    true
  
  val default_initial_assumption (temp___expr_174: int) (temp___skip_top_level_175: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_174 : int))
                   (temp___skip_top_level_175 : bool)) }
end

module Selfdrivingcar__chargelevel___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__chargelevel as Selfdrivingcar__chargelevel
  
  predicate dynamic_invariant (temp___expr_180: int) (temp___is_init_176: bool) (temp___skip_constant_177: bool) (temp___do_toplevel_178: bool) (temp___do_typ_inv_179: bool) =
    if ((temp___is_init_176 = True) \/
          (Selfdrivingcar__chargelevel.first
             <= Selfdrivingcar__chargelevel.last)) then
      (((Selfdrivingcar__chargelevel.dynamic_property
           Selfdrivingcar__chargelevel.first)
          Selfdrivingcar__chargelevel.last)
         temp___expr_180)
    else true
  
  val dynamic_invariant (temp___expr_180: int) (temp___is_init_176: bool) (temp___skip_constant_177: bool) (temp___do_toplevel_178: bool) (temp___do_typ_inv_179: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_180 : int))
                      (temp___is_init_176 : bool))
                     (temp___skip_constant_177 : bool))
                    (temp___do_toplevel_178 : bool))
                   (temp___do_typ_inv_179 : bool)) }
  
  predicate default_initial_assumption (temp___expr_181: int) (temp___skip_top_level_182: bool) =
    true
  
  val default_initial_assumption (temp___expr_181: int) (temp___skip_top_level_182: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_181 : int))
                   (temp___skip_top_level_182 : bool)) }
end

module Selfdrivingcar__carspeed___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__carspeed as Selfdrivingcar__carspeed
  
  predicate dynamic_invariant (temp___expr_187: int) (temp___is_init_183: bool) (temp___skip_constant_184: bool) (temp___do_toplevel_185: bool) (temp___do_typ_inv_186: bool) =
    if ((temp___is_init_183 = True) \/
          (Selfdrivingcar__carspeed.first <= Selfdrivingcar__carspeed.last)) then
      (((Selfdrivingcar__carspeed.dynamic_property
           Selfdrivingcar__carspeed.first)
          Selfdrivingcar__carspeed.last)
         temp___expr_187)
    else true
  
  val dynamic_invariant (temp___expr_187: int) (temp___is_init_183: bool) (temp___skip_constant_184: bool) (temp___do_toplevel_185: bool) (temp___do_typ_inv_186: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_187 : int))
                      (temp___is_init_183 : bool))
                     (temp___skip_constant_184 : bool))
                    (temp___do_toplevel_185 : bool))
                   (temp___do_typ_inv_186 : bool)) }
  
  predicate default_initial_assumption (temp___expr_188: int) (temp___skip_top_level_189: bool) =
    true
  
  val default_initial_assumption (temp___expr_188: int) (temp___skip_top_level_189: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_188 : int))
                   (temp___skip_top_level_189 : bool)) }
end

module Selfdrivingcar__object___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__object as Selfdrivingcar__object
  
  predicate dynamic_invariant (temp___expr_194: int) (temp___is_init_190: bool) (temp___skip_constant_191: bool) (temp___do_toplevel_192: bool) (temp___do_typ_inv_193: bool) =
    if ((temp___is_init_190 = True) \/
          (Selfdrivingcar__object.first <= Selfdrivingcar__object.last)) then
      (((Selfdrivingcar__object.dynamic_property Selfdrivingcar__object.first)
          Selfdrivingcar__object.last)
         temp___expr_194)
    else true
  
  val dynamic_invariant (temp___expr_194: int) (temp___is_init_190: bool) (temp___skip_constant_191: bool) (temp___do_toplevel_192: bool) (temp___do_typ_inv_193: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_194 : int))
                      (temp___is_init_190 : bool))
                     (temp___skip_constant_191 : bool))
                    (temp___do_toplevel_192 : bool))
                   (temp___do_typ_inv_193 : bool)) }
  
  predicate default_initial_assumption (temp___expr_195: int) (temp___skip_top_level_196: bool) =
    true
  
  val default_initial_assumption (temp___expr_195: int) (temp___skip_top_level_196: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_195 : int))
                   (temp___skip_top_level_196 : bool)) }
end

module Selfdrivingcar__diagnosticmode___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__diagnosticmode as Selfdrivingcar__diagnosticmode
  
  predicate dynamic_invariant (temp___expr_201: int) (temp___is_init_197: bool) (temp___skip_constant_198: bool) (temp___do_toplevel_199: bool) (temp___do_typ_inv_200: bool) =
    if ((temp___is_init_197 = True) \/
          (Selfdrivingcar__diagnosticmode.first
             <= Selfdrivingcar__diagnosticmode.last)) then
      (((Selfdrivingcar__diagnosticmode.dynamic_property
           Selfdrivingcar__diagnosticmode.first)
          Selfdrivingcar__diagnosticmode.last)
         temp___expr_201)
    else true
  
  val dynamic_invariant (temp___expr_201: int) (temp___is_init_197: bool) (temp___skip_constant_198: bool) (temp___do_toplevel_199: bool) (temp___do_typ_inv_200: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_201 : int))
                      (temp___is_init_197 : bool))
                     (temp___skip_constant_198 : bool))
                    (temp___do_toplevel_199 : bool))
                   (temp___do_typ_inv_200 : bool)) }
  
  predicate default_initial_assumption (temp___expr_202: int) (temp___skip_top_level_203: bool) =
    true
  
  val default_initial_assumption (temp___expr_202: int) (temp___skip_top_level_203: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_202 : int))
                   (temp___skip_top_level_203 : bool)) }
end

module Selfdrivingcar__chargestate___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__chargestate as Selfdrivingcar__chargestate
  
  predicate dynamic_invariant (temp___expr_208: int) (temp___is_init_204: bool) (temp___skip_constant_205: bool) (temp___do_toplevel_206: bool) (temp___do_typ_inv_207: bool) =
    if ((temp___is_init_204 = True) \/
          (Selfdrivingcar__chargestate.first
             <= Selfdrivingcar__chargestate.last)) then
      (((Selfdrivingcar__chargestate.dynamic_property
           Selfdrivingcar__chargestate.first)
          Selfdrivingcar__chargestate.last)
         temp___expr_208)
    else true
  
  val dynamic_invariant (temp___expr_208: int) (temp___is_init_204: bool) (temp___skip_constant_205: bool) (temp___do_toplevel_206: bool) (temp___do_typ_inv_207: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_208 : int))
                      (temp___is_init_204 : bool))
                     (temp___skip_constant_205 : bool))
                    (temp___do_toplevel_206 : bool))
                   (temp___do_typ_inv_207 : bool)) }
  
  predicate default_initial_assumption (temp___expr_209: int) (temp___skip_top_level_210: bool) =
    true
  
  val default_initial_assumption (temp___expr_209: int) (temp___skip_top_level_210: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_209 : int))
                   (temp___skip_top_level_210 : bool)) }
end

module Selfdrivingcar__thecar___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Selfdrivingcar__enablediagnosticmode__subprogram_def
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use _gnatprove_standard.Main as Main
  use _gnatprove_standard.Boolean as Boolean
  use Selfdrivingcar__thecar as Selfdrivingcar__thecar
  use Selfdrivingcar__car as Selfdrivingcar__car
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__onoff as Selfdrivingcar__onoff
  use Selfdrivingcar__onoff__rep as Selfdrivingcar__onoff__rep
  use Selfdrivingcar__diagnosticmode as Selfdrivingcar__diagnosticmode
  use Selfdrivingcar__diagnosticmode__rep as Selfdrivingcar__diagnosticmode__rep
  use Selfdrivingcar__onoff___axiom as Selfdrivingcar__onoff___axiom
  use Selfdrivingcar__gearbox___axiom as Selfdrivingcar__gearbox___axiom
  use Selfdrivingcar__chargelevel___axiom as Selfdrivingcar__chargelevel___axiom
  use Selfdrivingcar__carspeed___axiom as Selfdrivingcar__carspeed___axiom
  use Selfdrivingcar__object___axiom as Selfdrivingcar__object___axiom
  use Selfdrivingcar__diagnosticmode___axiom as Selfdrivingcar__diagnosticmode___axiom
  use Selfdrivingcar__chargestate___axiom as Selfdrivingcar__chargestate___axiom
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__thecar___axiom as Selfdrivingcar__thecar___axiom
  
  let def (__void_param : unit)
    requires { [#"selfdrivingcar.ads" 69 0 0] true }
    ensures { [#"selfdrivingcar.ads" 69 0 0]
              [#"selfdrivingcar.ads" 72 0 0]
              [@GP_Reason:VC_POSTCONDITION]
              [@comment:     Post => TheCar.switch = Off and TheCar.diagnostic = On;              ^ selfdrivingcar.ads:72:14:VC_POSTCONDITION]
              [@GP_Sloc:selfdrivingcar.ads:72:14]
              [@model_vc_post]
              [@GP_Shape:pragargs__and]
              [@GP_Id:6]
              (([@GP_Pretty_Ada:1265]
                [@GP_Sloc:selfdrivingcar.ads:72:14]
                ((Selfdrivingcar__onoff__rep.to_rep
                    ((Selfdrivingcar__car.__split_fields
                         { Selfdrivingcar__car.__split_fields =
                             (Selfdrivingcar__car.__split_fields__content
                                 Selfdrivingcar__thecar.thecar__split_fields) }).
                       Selfdrivingcar__car.rec__selfdrivingcar__car__switch))
                   = (1 : int))) /\
                 ([@GP_Sloc:selfdrivingcar.ads:72:38]
                  [@GP_Pretty_Ada:1271]
                  ((Selfdrivingcar__diagnosticmode__rep.to_rep
                      ((Selfdrivingcar__car.__split_fields
                           { Selfdrivingcar__car.__split_fields =
                               (Selfdrivingcar__car.__split_fields__content
                                   Selfdrivingcar__thecar.thecar__split_fields) }).
                         Selfdrivingcar__car.rec__selfdrivingcar__car__diagnostic))
                     = (0 : int)))) }
  = [@vc:divergent]
    (([@GNAT-comment:Assume dynamic invariants of inputs of the subprogram selfdrivingcar.ads:69]
      ());
     assume {
       ((((Selfdrivingcar__car___axiom.dynamic_invariant
             { Selfdrivingcar__car.__split_fields =
                 (Selfdrivingcar__car.__split_fields__content
                     Selfdrivingcar__thecar.thecar__split_fields) })
            True)
           False)
          True)
         True };
     ([@GNAT-comment:Assume moved pointers in outputs of the subprogram selfdrivingcar.ads:69]
      ());
     ([@GNAT-comment:Check for RTE in the Pre of the subprogram selfdrivingcar.ads:69]
      ());
     (begin
        ensures { true }
        let _ =
          let _ =
            (Boolean.andb
               ((Selfdrivingcar__onoff__rep.to_rep
                   ((Selfdrivingcar__car.__split_fields
                        { Selfdrivingcar__car.__split_fields =
                            (Selfdrivingcar__car.__split_fields__content
                                Selfdrivingcar__thecar.thecar__split_fields) }).
                      Selfdrivingcar__car.rec__selfdrivingcar__car__switch))
                  = (0 : int)))
              ((Selfdrivingcar__diagnosticmode__rep.to_rep
                  ((Selfdrivingcar__car.__split_fields
                       { Selfdrivingcar__car.__split_fields =
                           (Selfdrivingcar__car.__split_fields__content
                               Selfdrivingcar__thecar.thecar__split_fields) }).
                     Selfdrivingcar__car.rec__selfdrivingcar__car__diagnostic))
                 = (1 : int)) in
          () in
        ()
      end);
     ([@GNAT-comment:Assume Pre of the subprogram selfdrivingcar.ads:69] ());
     assume {
       (([@GP_Pretty_Ada:1251]
         ((Selfdrivingcar__onoff__rep.to_rep
             ((Selfdrivingcar__car.__split_fields
                  { Selfdrivingcar__car.__split_fields =
                      (Selfdrivingcar__car.__split_fields__content
                          Selfdrivingcar__thecar.thecar__split_fields) }).
                Selfdrivingcar__car.rec__selfdrivingcar__car__switch))
            = (0 : int))) /\
          ([@GP_Pretty_Ada:1257]
           ((Selfdrivingcar__diagnosticmode__rep.to_rep
               ((Selfdrivingcar__car.__split_fields
                    { Selfdrivingcar__car.__split_fields =
                        (Selfdrivingcar__car.__split_fields__content
                            Selfdrivingcar__thecar.thecar__split_fields) }).
                  Selfdrivingcar__car.rec__selfdrivingcar__car__diagnostic))
              = (1 : int)))) };
     (try
        ([@GP_Sloc:selfdrivingcar.adb:55:11]
         [#"selfdrivingcar.adb" 55 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:55:7]
         [#"selfdrivingcar.adb" 55 0 0]
         (if (([#"selfdrivingcar.adb" 55 0 0]
               [#"selfdrivingcar.adb" 55 0 0]
               (([@branch_id=946] Main.spark__branch).bool__content <-
                  ((Selfdrivingcar__onoff__rep.to_rep
                      ((Selfdrivingcar__car.__split_fields
                           { Selfdrivingcar__car.__split_fields =
                               (Selfdrivingcar__car.__split_fields__content
                                   Selfdrivingcar__thecar.thecar__split_fields) }).
                         Selfdrivingcar__car.rec__selfdrivingcar__car__switch))
                     = (0 : int))));
              (([@branch_id=946] Main.spark__branch).bool__content)) then
            (([@GP_Sloc:selfdrivingcar.adb:56:12]
              [#"selfdrivingcar.adb" 56 0 0] ());
             ([@GP_Sloc:selfdrivingcar.adb:56:26]
              [#"selfdrivingcar.adb" 56 0 0]
              (let temp___258 =
                 let temp___257 =
                   { Selfdrivingcar__car.__split_fields =
                       (Selfdrivingcar__car.__split_fields__content
                           Selfdrivingcar__thecar.thecar__split_fields) } in
                 ([#"selfdrivingcar.adb" 56 0 0]
                  (begin
                     ensures { true }
                     let _ =
                       let _ =
                         (Selfdrivingcar__car.__split_fields temp___257).
                           Selfdrivingcar__car.rec__selfdrivingcar__car__switch in
                       () in
                     ()
                   end));
                 ({ temp___257 with
                    Selfdrivingcar__car.__split_fields =
                      ({ (Selfdrivingcar__car.__split_fields temp___257) with
                         Selfdrivingcar__car.rec__selfdrivingcar__car__switch =
                           (Selfdrivingcar__onoff__rep.of_rep (1 : int)) }) }) in
               [#"selfdrivingcar.adb" 56 0 0]
               (Selfdrivingcar__thecar.thecar__split_fields.Selfdrivingcar__car.__split_fields__content <-
                  (Selfdrivingcar__car.__split_fields temp___258))));
             ([@GP_Sloc:selfdrivingcar.adb:56:34]
              [#"selfdrivingcar.adb" 56 0 0] ());
             ([@GP_Sloc:selfdrivingcar.adb:56:52]
              [#"selfdrivingcar.adb" 56 0 0]
              (let temp___261 =
                 let temp___260 =
                   { Selfdrivingcar__car.__split_fields =
                       (Selfdrivingcar__car.__split_fields__content
                           Selfdrivingcar__thecar.thecar__split_fields) } in
                 ([#"selfdrivingcar.adb" 56 0 0]
                  (begin
                     ensures { true }
                     let _ =
                       let _ =
                         (Selfdrivingcar__car.__split_fields temp___260).
                           Selfdrivingcar__car.rec__selfdrivingcar__car__diagnostic in
                       () in
                     ()
                   end));
                 ({ temp___260 with
                    Selfdrivingcar__car.__split_fields =
                      ({ (Selfdrivingcar__car.__split_fields temp___260) with
                         Selfdrivingcar__car.rec__selfdrivingcar__car__diagnostic =
                           (Selfdrivingcar__diagnosticmode__rep.of_rep
                              (0 : int)) }) }) in
               [#"selfdrivingcar.adb" 56 0 0]
               (Selfdrivingcar__thecar.thecar__split_fields.Selfdrivingcar__car.__split_fields__content <-
                  (Selfdrivingcar__car.__split_fields temp___261)))))
          else ()));
        (raise Return__exc)
      with Return__exc -> ()
      end);
     (begin
        ensures { true }
        let _ =
          let _ =
            (Boolean.andb
               ((Selfdrivingcar__onoff__rep.to_rep
                   ((Selfdrivingcar__car.__split_fields
                        { Selfdrivingcar__car.__split_fields =
                            (Selfdrivingcar__car.__split_fields__content
                                Selfdrivingcar__thecar.thecar__split_fields) }).
                      Selfdrivingcar__car.rec__selfdrivingcar__car__switch))
                  = (1 : int)))
              ((Selfdrivingcar__diagnosticmode__rep.to_rep
                  ((Selfdrivingcar__car.__split_fields
                       { Selfdrivingcar__car.__split_fields =
                           (Selfdrivingcar__car.__split_fields__content
                               Selfdrivingcar__thecar.thecar__split_fields) }).
                     Selfdrivingcar__car.rec__selfdrivingcar__car__diagnostic))
                 = (0 : int)) in
          () in
        ()
      end))
end
